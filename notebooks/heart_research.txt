{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0de6c7e1",
   "metadata": {},
   "source": [
    "# Heart AI — Explanatory Research Notebook\n",
    "\n",
    "**Purpose:** This notebook explains a research-only ECG-based AI prototype for detecting arrhythmia-like patterns, discusses regulatory and ethical constraints, and describes how such a model could help internally displaced persons (IDPs) and rural communities. **This is not clinical software.**\n",
    "\n",
    "**Contents:**\n",
    "\n",
    "1. Project overview and scope\n",
    "2. Problems faced by IDPs & rural communities\n",
    "3. How the model could help (use-cases)\n",
    "4. Data & preprocessing (small synthetic demo)\n",
    "5. Simple PyTorch 1D-CNN demo trained on synthetic data (lightweight)\n",
    "6. Explainability demo (saliency via gradients)\n",
    "7. Deployment & privacy considerations\n",
    "8. Limitations, risks, and next steps\n",
    "\n",
    "---\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "20d06ce6",
   "metadata": {},
   "source": [
    "## 1 — Project overview & scope\n",
    "\n",
    "This notebook is a research-oriented explanation of a prototype pipeline that *flags* possible abnormal ECG rhythm patterns from single-lead recordings. It focuses on design, explainability, privacy, and how such a system might deliver value in low-resource settings (IDP camps, rural clinics).\n",
    "\n",
    "**Key constraints:**\n",
    "\n",
    "- Not a diagnostic device — research-only. Clinical validation and regulatory clearance required before any clinical use.\n",
    "- Privacy, consent, and clinician-in-the-loop are mandatory design principles.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d04ec38c",
   "metadata": {},
   "source": [
    "## 2 — Problems faced by IDPs and rural communities (relevant to cardiac health)\n",
    "\n",
    "Internally Displaced Persons (IDPs) and rural populations face a cluster of healthcare access problems that increase cardiovascular risk and reduce opportunities for timely care:\n",
    "\n",
    "- **Limited access to trained clinicians:** Few cardiologists or ECG-capable clinics.\n",
    "- **Scarce diagnostic equipment:** Clinics may lack ECG machines or have unreliable devices.\n",
    "- **Delayed care & transport barriers:** Patients may not reach tertiary centers quickly.\n",
    "- **Low health literacy and cultural barriers:** Symptoms may be unrecognized or dismissed.\n",
    "- **Data fragmentation & poor records:** Hard to track follow-ups and history.\n",
    "- **Resource constraints:** Limited power, unreliable internet, or no continuous monitoring.\n",
    "\n",
    "These constraints create opportunities for lightweight, robust, explainable AI tools that can run on low-cost hardware (smartphones, portable ECG devices) to **flag** at-risk patients and prioritize referrals.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1e5a39fb",
   "metadata": {},
   "source": [
    "## 3 — How this model could help (use-cases)\n",
    "\n",
    "Below are practical ways a research ECG flagging model could add value in low-resource settings:\n",
    "\n",
    "1. **Triage at community clinics / IDP camp clinics** — run a single-lead ECG and flag probable arrhythmias for immediate review, speeding referral decisions.\n",
    "\n",
    "2. **Task-shifting and telemedicine augmentation** — enable nurses or community health workers to collect ECGs and send flagged cases to remote clinicians, reducing workload.\n",
    "\n",
    "3. **Screening during outreach campaigns** — portable devices + offline model can screen many people quickly and identify those needing follow-up.\n",
    "\n",
    "4. **Longitudinal monitoring for known patients** — periodically check high-risk individuals and alert when model confidence for abnormality rises.\n",
    "\n",
    "5. **Resource optimization** — reduce unnecessary referrals by prioritizing those with higher model-predicted risk, while preserving clinician oversight.\n",
    "\n",
    "**Important:** Always present model outputs with confidence, allow clinician override, and clearly state limitations.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e97ffb8c",
   "metadata": {},
   "source": [
    "### Practical design considerations for IDP / rural deployment\n",
    "\n",
    "- **Offline-first inference:** Keep model small and efficient; inference on mobile/edge without internet.\n",
    "- **Low-power & small storage:** Quantize model, use memory-efficient signal processing.\n",
    "- **Simple UI for health workers:** Clear flags, confidence, and recommended action (e.g., urgent referral, send to clinician).\n",
    "- **Audit & logging rules:** Minimal PHI storage; encrypted logs; local temporary storage with scheduled deletion.\n",
    "- **Training data representativeness:** Validate model against populations with similar demographics and device characteristics.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cebfd14b",
   "metadata": {},
   "source": [
    "## 4 — Synthetic data demo (why synthetic?)\n",
    "\n",
    "To keep this notebook runnable without external downloads and to avoid using real PHI, we simulate synthetic ECG-like waveforms and two classes: `normal-like` and `abnormal-like` (arrhythmia-like). The demo trains a tiny PyTorch 1D-CNN on the synthetic data and shows a simple saliency explanation.\n",
    "\n",
    "This is purely illustrative — results on synthetic data do not reflect real clinical performance.\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7325143",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Basic imports and deterministic seed\n",
    "import numpy as np\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "import matplotlib.pyplot as plt\n",
    "np.random.seed(42)\n",
    "torch.manual_seed(42)\n",
    "print('Torch version:', torch.__version__)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6cf10987",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Synthetic ECG-like signal generator\n",
    "def synth_ecg(length=500, fs=250, noise_level=0.05, abnormal=False):\n",
    "    t = np.linspace(0, length/fs, length)\n",
    "    # base sinus rhythm-like oscillation\n",
    "    base = 0.6 * np.sin(2 * np.pi * 1.0 * t)  # ~1 Hz \"heart\" rhythm\n",
    "    # add higher-frequency components\n",
    "    hf = 0.05 * np.sin(2 * np.pi * 20 * t) + 0.02 * np.sin(2 * np.pi * 50 * t)\n",
    "    sig = base + hf\n",
    "    # if abnormal, insert irregular pulses / ectopic beats\n",
    "    if abnormal:\n",
    "        for _ in range(np.random.randint(1,4)):\n",
    "            pos = np.random.randint(50, length-50)\n",
    "            amp = np.random.uniform(-1.0, 1.0)\n",
    "            width = np.random.randint(3, 12)\n",
    "            sig[pos:pos+width] += amp * np.hanning(width)\n",
    "    # noise\n",
    "    sig += noise_level * np.random.randn(length)\n",
    "    # normalize\n",
    "    sig = (sig - sig.mean()) / (sig.std() + 1e-9)\n",
    "    return sig\n",
    "\n",
    "# generate dataset\n",
    "N = 800\n",
    "X = np.zeros((N, 500), dtype=np.float32)\n",
    "y = np.zeros(N, dtype=np.int64)\n",
    "for i in range(N):\n",
    "    if np.random.rand() < 0.4:\n",
    "        X[i] = synth_ecg(abnormal=True)\n",
    "        y[i] = 1\n",
    "    else:\n",
    "        X[i] = synth_ecg(abnormal=False)\n",
    "        y[i] = 0\n",
    "\n",
    "print('Dataset shapes', X.shape, y.shape)\n",
    "plt.plot(X[:5].T)\n",
    "plt.title('Example synthetic ECG-like traces (first 5 samples)')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1803b2db",
   "metadata": {},
   "outputs": [],
   "source": [
    "class ECGDataset(Dataset):\n",
    "    def __init__(self, X, y):\n",
    "        self.X = X\n",
    "        self.y = y\n",
    "    def __len__(self):\n",
    "        return len(self.X)\n",
    "    def __getitem__(self, idx):\n",
    "        return np.expand_dims(self.X[idx],0).astype(np.float32), int(self.y[idx])\n",
    "\n",
    "# split\n",
    "perm = np.random.permutation(N)\n",
    "train_idx = perm[:600]\n",
    "val_idx = perm[600:700]\n",
    "test_idx = perm[700:]\n",
    "\n",
    "train_ds = ECGDataset(X[train_idx], y[train_idx])\n",
    "val_ds = ECGDataset(X[val_idx], y[val_idx])\n",
    "test_ds = ECGDataset(X[test_idx], y[test_idx])\n",
    "\n",
    "train_loader = DataLoader(train_ds, batch_size=32, shuffle=True)\n",
    "val_loader = DataLoader(val_ds, batch_size=64)\n",
    "print('Train samples', len(train_ds), 'Val samples', len(val_ds), 'Test samples', len(test_ds))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "72fe2094",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TinyECGCNN(nn.Module):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.conv1 = nn.Conv1d(1, 16, kernel_size=7, padding=3)\n",
    "        self.bn1 = nn.BatchNorm1d(16)\n",
    "        self.pool = nn.MaxPool1d(2)\n",
    "        self.conv2 = nn.Conv1d(16, 32, kernel_size=5, padding=2)\n",
    "        self.bn2 = nn.BatchNorm1d(32)\n",
    "        self.gap = nn.AdaptiveAvgPool1d(1)\n",
    "        self.fc = nn.Linear(32, 2)\n",
    "    def forward(self, x):\n",
    "        x = torch.relu(self.bn1(self.conv1(x)))\n",
    "        x = self.pool(x)\n",
    "        x = torch.relu(self.bn2(self.conv2(x)))\n",
    "        x = self.gap(x).squeeze(-1)\n",
    "        x = self.fc(x)\n",
    "        return x\n",
    "\n",
    "device = 'cuda' if torch.cuda.is_available() else 'cpu'\n",
    "model = TinyECGCNN().to(device)\n",
    "print(model)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9ef25695",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate(model, loader):\n",
    "    model.eval()\n",
    "    correct = 0\n",
    "    total = 0\n",
    "    with torch.no_grad():\n",
    "        for xb, yb in loader:\n",
    "            xb = xb.to(device).float()\n",
    "            yb = yb.to(device)\n",
    "            out = model(xb)\n",
    "            pred = out.argmax(dim=1)\n",
    "            correct += (pred == yb).sum().item()\n",
    "            total += yb.size(0)\n",
    "    return correct/total\n",
    "\n",
    "opt = optim.Adam(model.parameters(), lr=1e-3)\n",
    "loss_fn = nn.CrossEntropyLoss()\n",
    "\n",
    "for epoch in range(8):\n",
    "    model.train()\n",
    "    running = 0.0\n",
    "    for xb, yb in train_loader:\n",
    "        xb = xb.to(device).float()\n",
    "        yb = yb.to(device)\n",
    "        opt.zero_grad()\n",
    "        out = model(xb)\n",
    "        loss = loss_fn(out, yb)\n",
    "        loss.backward()\n",
    "        opt.step()\n",
    "        running += loss.item()\n",
    "    val_acc = evaluate(model, val_loader)\n",
    "    print(f'Epoch {epoch+1} loss {running/len(train_loader):.4f} val_acc {val_acc:.3f}')\n",
    "\n",
    "print('Test accuracy:', evaluate(model, test_ds))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3e673530",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Simple gradient-based saliency for one example\n",
    "model.eval()\n",
    "sample_x, sample_y = test_ds[3]\n",
    "input_tensor = torch.tensor(np.expand_dims(sample_x,0)).to(device).float()\n",
    "input_tensor.requires_grad = True\n",
    "out = model(input_tensor)\n",
    "score = out[0, sample_y]\n",
    "score.backward()\n",
    "saliency = input_tensor.grad.detach().cpu().numpy()[0,0]\n",
    "\n",
    "plt.figure(figsize=(10,3))\n",
    "plt.plot(sample_x[0], label='signal')\n",
    "plt.plot(saliency / (np.max(np.abs(saliency))+1e-9), label='saliency (scaled)')\n",
    "plt.legend()\n",
    "plt.title('Signal and gradient-based saliency (one test example)')\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a5401f4d",
   "metadata": {},
   "source": [
    "## 5 — Deployment & privacy considerations\n",
    "\n",
    "**Edge-first deployment:** Convert and quantize the trained model (e.g., TorchScript / ONNX + quantization) so it runs on mobile devices or small edge boxes without internet.\n",
    "\n",
    "**Local-only PHI handling:** Store minimal PHI locally; if sending data to remote clinicians, use TLS and ensure a secure BAA-compliant backend.\n",
    "\n",
    "**Consent & UI:** The UI should show the purpose, limitations, and require explicit consent before capturing ECGs. Provide clear next steps for flagged cases (call clinician, urgent referral, educational material).\n",
    "\n",
    "**Audit & logging:** Keep encrypted logs of flagged events with minimal identifiers. Implement scheduled log deletion where appropriate.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "43d6a1dc",
   "metadata": {},
   "source": [
    "## 6 — Limitations, risks, and required governance\n",
    "\n",
    "- **Not a diagnostic device:** This prototype is research-only. Clinical trials and regulatory clearances are mandatory before any diagnostic use.\n",
    "- **Dataset shift risk:** Performance on real ECG devices, different electrode placements, and varying noise profiles will differ — retraining/fine-tuning on local data is essential.\n",
    "- **Bias & equity:** Must evaluate performance across age, sex, skin tones, and device types.\n",
    "- **Security & privacy risks:** Mishandled PHI can cause severe harm; design for minimal data retention and strong encryption.\n",
    "\n",
    "**Governance checklist (minimum):**\n",
    "- Document dataset provenance and consent\n",
    "- Clinical validation plan and independent clinician review\n",
    "- Regulatory strategy: FDA/CE/MDR mapping\n",
    "- Privacy Impact Assessment (DPIA) for EU and equivalent for other jurisdictions\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "18a021d5",
   "metadata": {},
   "source": [
    "## 7 — Suggested focused interventions for IDP & rural settings (operational)\n",
    "\n",
    "1. **Screen-and-refer pilot:** Run a pilot in a few clinics with trained community health workers collecting single-lead ECGs using a low-cost device. Use the model to flag cases and send them to a remote cardiology review team.\n",
    "\n",
    "2. **Mobile health (mHealth) kit:** Edge model + small battery-backed tablet/smartphone + portable ECG leads; offline-first; sync when internet available.\n",
    "\n",
    "3. **Training & task-shifting:** Train nurses and CHWs on using the device and interpreting the model output responsibly, emphasizing that final decisions rest with clinicians.\n",
    "\n",
    "4. **Data collection for local retraining:** With consent, collect anonymized local ECGs to fine-tune the model and reduce dataset shift.\n",
    "\n",
    "5. **Referral prioritization protocol:** Combine model output with simple clinical checklists (chest pain, shortness of breath, syncope) to prioritize urgent transports.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2f6d5434",
   "metadata": {},
   "source": [
    "## 8 — Next steps & resources\n",
    "\n",
    "- If this research direction is useful, the next concrete steps are:\n",
    "  1. Acquire small labeled ECG dataset from local clinics (with consent and ethics approval).\n",
    "  2. Replace synthetic demo with real preprocessing (wfdb / PhysioNet) and subject-wise splits.\n",
    "  3. Add robust explainability (Integrated Gradients, SHAP) and clinician-facing visualizations.\n",
    "  4. Draft a clinical evaluation plan and contact regulatory consultants.\n",
    "\n",
    "**References & further reading (select):** PhysioNet MIT-BIH Arrhythmia Database, FDA AI/ML SaMD guidance, WHO mHealth guidance for low-resource settings. Ensure you consult legal and clinical experts before any pilot.\n",
    "\n",
    "---\n",
    "\n",
    "**End of notebook.**\n"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 5
}
